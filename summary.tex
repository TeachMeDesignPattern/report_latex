\section{项目总结}

\subsection{硬件模拟器开发的难点}

在本小组的 Slow6502 项目中，我们实现了理论课上讲到的所有 23 个 GoF 设计模式，以及 8 个不属于 GoF 的设计模式。这些设计模式使用并非生搬硬套，而是符合项目的实际情况的。相比较常规的业务软件，构建一个硬件平台的指令级模拟软件，主要面临以下几个难点：
\begin{enumerate}
    \item 硬件模拟器的行为十分复杂，且必须进行精准的复刻
    \item 硬件平台结构和组成十分复杂，且在各类文档中的抽象层次不一致
    \item 用户对于硬件模拟器的灵活性要求较高，需要能够模拟不同型号的处理机变种、内存、外设等
    \item 由于面向的用户大多为专业用户，故而硬件模拟器的源码需要有良好的可扩展潜力，以方便用户进行自行修改
    \item 硬件模拟器需要一定的执行效率
\end{enumerate}

目前最广泛使用的 QEMU 为了执行效率和模拟的精准性，而牺牲了源码的可维护性。考虑到目前的常见设备的计算能力通常是 MOS 6502 的数万倍，故而模拟器的性能并不构成问题（这也就是我们项目中 Slow 一词）的由来。为了保证模拟硬件行为的正确性，并保证代码的可维护性，我买需要对硬件设备以及其运行过程的各个层次进行抽象，同时使用设计模式使得代码能够被更加灵活地复用和修改。

\subsection{设计模式的意义}
这里以我们项目中的寄存器为例，总结一下设计模式在这个项目中的关键作用：
\begin{enumerate}
    \item 保障行为的准确实现
    \item 方便测试和验证
    \item 减少变更和重构的工作量
\end{enumerate}

\paragraph{保障行为的准确实现} 虽然 6502 只有 6 个寄存器（FLAG，SP，PC，A，X，Y），但这 6 个寄存器在行为上各有特点，但又有着千丝万缕的联系。传统的硬件模拟器中，通常使用结构体直接保存寄存器的内容，然后通过一系列冗长复杂的控制流（例如超过 3 层的 if-else 语句，大块嵌套的 switch-case）等，来实现这些相似但又不完全相同的功能。当然，如果有足够的时间和精力，这些控制流是可以被正确实现的。但在当今的开发节奏下（例如在一周之内完成一轮敏捷开发），这样编写逻辑的方式是行不通的。

因而，我们需要使用设计模式引入合适的抽象，从而将“揉成一团”的逻辑拆分成小块，然后逐一进行实现。我们的代码中，除了极少部分的特殊情况，几乎没有出现超过 100 行的代码块，或者超过 3 层的 if 语句。合理的顶层设计配合语言的特性，加上设计模式的指导，使得准确实现预定的逻辑变得较为容易。

\paragraph{方便测试和验证} 小块封装好的代码除了可以减轻开发人员的心智负担外，也可以方便对于程序的质量控制。一个显而易见的优点是单元测试变得十分简单。测试一个如 \lstinline{getNegativeFlag()} 的简单方法，要远比测试一堆不知所云的 if-else 并试图找出哪里出现了问题要简单的多。

除了单元测试外，集成测试也能从设计模式中受益。在这些小块的方法中，我们可以对逻辑中的不变量（invariant）进行断言，这样在集成测试时，出现的问题可以迅速通过失败的断言被找到。

\paragraph{减少变更和重构的工作量} 一方面，通过一系列合理设计的设计模式构建的源码，本身就为变更和重构提供了丰富的工具。诸如 \lstinline{getNegativeFlag()} 等方法，使得我们重构时可以不必修改大量的实现细节。

另一方面，即便是对于 \lstinline{getNegativeFlag()} 等方法本身的修改，也不必担心对于其他源码的影响。一个我们亲身经历上的例子是在一次大规模的重构后，各个小队依次直接进行了 merge ，没有出现一个冲突，并且成功通过了所有的回归测试。



